// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace PackageKit {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public class Client : GLib.Object {

		[Obsolete]
		protected Client(GLib.GType gtype) : base(gtype) {}
		public Client(IntPtr raw) : base(raw) {}

		[DllImport("libpackagekit-glib.dll")]
		static extern IntPtr pk_client_new();

		public Client () : base (IntPtr.Zero)
		{
			if (GetType () != typeof (Client)) {
				CreateNativeObject (new string [0], new GLib.Value[0]);
				return;
			}
			Raw = pk_client_new();
		}

		[GLib.CDeclCallback]
		delegate void MessageVMDelegate (IntPtr client, int message, IntPtr details);

		static MessageVMDelegate MessageVMCallback;

		static void message_cb (IntPtr client, int message, IntPtr details)
		{
			try {
				Client client_managed = GLib.Object.GetObject (client, false) as Client;
				client_managed.OnMessage ((PackageKit.MessageEnum) message, GLib.Marshaller.Utf8PtrToString (details));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideMessage (GLib.GType gtype)
		{
			if (MessageVMCallback == null)
				MessageVMCallback = new MessageVMDelegate (message_cb);
			OverrideVirtualMethod (gtype, "message", MessageVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(PackageKit.Client), ConnectionMethod="OverrideMessage")]
		protected virtual void OnMessage (PackageKit.MessageEnum message, string details)
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (3);
			GLib.Value[] vals = new GLib.Value [3];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (message);
			inst_and_params.Append (vals [1]);
			vals [2] = new GLib.Value (details);
			inst_and_params.Append (vals [2]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("message")]
		public event PackageKit.MessageHandler Message {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "message", typeof (PackageKit.MessageArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "message", typeof (PackageKit.MessageArgs));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void DetailsVMDelegate (IntPtr client, IntPtr package_detail);

		static DetailsVMDelegate DetailsVMCallback;

		static void details_cb (IntPtr client, IntPtr package_detail)
		{
			try {
				Client client_managed = GLib.Object.GetObject (client, false) as Client;
				client_managed.OnDetails (package_detail == IntPtr.Zero ? null : (PackageKit.DetailsObj) GLib.Opaque.GetOpaque (package_detail, typeof (PackageKit.DetailsObj), false));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideDetails (GLib.GType gtype)
		{
			if (DetailsVMCallback == null)
				DetailsVMCallback = new DetailsVMDelegate (details_cb);
			OverrideVirtualMethod (gtype, "details", DetailsVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(PackageKit.Client), ConnectionMethod="OverrideDetails")]
		protected virtual void OnDetails (PackageKit.DetailsObj package_detail)
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (2);
			GLib.Value[] vals = new GLib.Value [2];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (package_detail);
			inst_and_params.Append (vals [1]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.CDeclCallback]
		delegate void DetailsSignalDelegate (IntPtr arg0, IntPtr arg1, IntPtr gch);

		static void DetailsSignalCallback (IntPtr arg0, IntPtr arg1, IntPtr gch)
		{
			PackageKit.DetailsArgs args = new PackageKit.DetailsArgs ();
			try {
				GLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;
				if (sig == null)
					throw new Exception("Unknown signal GC handle received " + gch);

				args.Args = new object[1];
				args.Args[0] = arg1 == IntPtr.Zero ? null : (PackageKit.DetailsObj) GLib.Opaque.GetOpaque (arg1, typeof (PackageKit.DetailsObj), false);
				PackageKit.DetailsHandler handler = (PackageKit.DetailsHandler) sig.Handler;
				handler (GLib.Object.GetObject (arg0), args);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.Signal("details")]
		public event PackageKit.DetailsHandler Details {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "details", new DetailsSignalDelegate(DetailsSignalCallback));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "details", new DetailsSignalDelegate(DetailsSignalCallback));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void CallerActiveChangedVMDelegate (IntPtr client, bool is_active);

		static CallerActiveChangedVMDelegate CallerActiveChangedVMCallback;

		static void calleractivechanged_cb (IntPtr client, bool is_active)
		{
			try {
				Client client_managed = GLib.Object.GetObject (client, false) as Client;
				client_managed.OnCallerActiveChanged (is_active);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideCallerActiveChanged (GLib.GType gtype)
		{
			if (CallerActiveChangedVMCallback == null)
				CallerActiveChangedVMCallback = new CallerActiveChangedVMDelegate (calleractivechanged_cb);
			OverrideVirtualMethod (gtype, "caller-active-changed", CallerActiveChangedVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(PackageKit.Client), ConnectionMethod="OverrideCallerActiveChanged")]
		protected virtual void OnCallerActiveChanged (bool is_active)
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (2);
			GLib.Value[] vals = new GLib.Value [2];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (is_active);
			inst_and_params.Append (vals [1]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("caller-active-changed")]
		public event PackageKit.CallerActiveChangedHandler CallerActiveChanged {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "caller-active-changed", typeof (PackageKit.CallerActiveChangedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "caller-active-changed", typeof (PackageKit.CallerActiveChangedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void ErrorCodeVMDelegate (IntPtr client, int code, IntPtr details);

		static ErrorCodeVMDelegate ErrorCodeVMCallback;

		static void errorcode_cb (IntPtr client, int code, IntPtr details)
		{
			try {
				Client client_managed = GLib.Object.GetObject (client, false) as Client;
				client_managed.OnErrorCode ((PackageKit.ErrorCodeEnum) code, GLib.Marshaller.Utf8PtrToString (details));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideErrorCode (GLib.GType gtype)
		{
			if (ErrorCodeVMCallback == null)
				ErrorCodeVMCallback = new ErrorCodeVMDelegate (errorcode_cb);
			OverrideVirtualMethod (gtype, "error-code", ErrorCodeVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(PackageKit.Client), ConnectionMethod="OverrideErrorCode")]
		protected virtual void OnErrorCode (PackageKit.ErrorCodeEnum code, string details)
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (3);
			GLib.Value[] vals = new GLib.Value [3];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (code);
			inst_and_params.Append (vals [1]);
			vals [2] = new GLib.Value (details);
			inst_and_params.Append (vals [2]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("error-code")]
		public event PackageKit.ErrorCodeHandler ErrorCode {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "error-code", typeof (PackageKit.ErrorCodeArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "error-code", typeof (PackageKit.ErrorCodeArgs));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void ProgressChangedVMDelegate (IntPtr client, uint percentage, uint subpercentage, uint elapsed, uint remaining);

		static ProgressChangedVMDelegate ProgressChangedVMCallback;

		static void progresschanged_cb (IntPtr client, uint percentage, uint subpercentage, uint elapsed, uint remaining)
		{
			try {
				Client client_managed = GLib.Object.GetObject (client, false) as Client;
				client_managed.OnProgressChanged (percentage, subpercentage, elapsed, remaining);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideProgressChanged (GLib.GType gtype)
		{
			if (ProgressChangedVMCallback == null)
				ProgressChangedVMCallback = new ProgressChangedVMDelegate (progresschanged_cb);
			OverrideVirtualMethod (gtype, "progress-changed", ProgressChangedVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(PackageKit.Client), ConnectionMethod="OverrideProgressChanged")]
		protected virtual void OnProgressChanged (uint percentage, uint subpercentage, uint elapsed, uint remaining)
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (5);
			GLib.Value[] vals = new GLib.Value [5];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (percentage);
			inst_and_params.Append (vals [1]);
			vals [2] = new GLib.Value (subpercentage);
			inst_and_params.Append (vals [2]);
			vals [3] = new GLib.Value (elapsed);
			inst_and_params.Append (vals [3]);
			vals [4] = new GLib.Value (remaining);
			inst_and_params.Append (vals [4]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("progress-changed")]
		public event PackageKit.ProgressChangedHandler ProgressChanged {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "progress-changed", typeof (PackageKit.ProgressChangedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "progress-changed", typeof (PackageKit.ProgressChangedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void PackageVMDelegate (IntPtr client, IntPtr obj);

		static PackageVMDelegate PackageVMCallback;

		static void package_cb (IntPtr client, IntPtr obj)
		{
			try {
				Client client_managed = GLib.Object.GetObject (client, false) as Client;
				client_managed.OnPackage (obj == IntPtr.Zero ? null : (PackageKit.PackageObj) GLib.Opaque.GetOpaque (obj, typeof (PackageKit.PackageObj), false));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverridePackage (GLib.GType gtype)
		{
			if (PackageVMCallback == null)
				PackageVMCallback = new PackageVMDelegate (package_cb);
			OverrideVirtualMethod (gtype, "package", PackageVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(PackageKit.Client), ConnectionMethod="OverridePackage")]
		protected virtual void OnPackage (PackageKit.PackageObj obj)
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (2);
			GLib.Value[] vals = new GLib.Value [2];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (obj);
			inst_and_params.Append (vals [1]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.CDeclCallback]
		delegate void PackageSignalDelegate (IntPtr arg0, IntPtr arg1, IntPtr gch);

		static void PackageSignalCallback (IntPtr arg0, IntPtr arg1, IntPtr gch)
		{
			PackageKit.PackageArgs args = new PackageKit.PackageArgs ();
			try {
				GLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;
				if (sig == null)
					throw new Exception("Unknown signal GC handle received " + gch);

				args.Args = new object[1];
				args.Args[0] = arg1 == IntPtr.Zero ? null : (PackageKit.PackageObj) GLib.Opaque.GetOpaque (arg1, typeof (PackageKit.PackageObj), false);
				PackageKit.PackageHandler handler = (PackageKit.PackageHandler) sig.Handler;
				handler (GLib.Object.GetObject (arg0), args);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.Signal("package")]
		public event PackageKit.PackageHandler Package {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "package", new PackageSignalDelegate(PackageSignalCallback));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "package", new PackageSignalDelegate(PackageSignalCallback));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void AllowCancelVMDelegate (IntPtr client, bool allow_cancel);

		static AllowCancelVMDelegate AllowCancelVMCallback;

		static void allowcancel_cb (IntPtr client, bool allow_cancel)
		{
			try {
				Client client_managed = GLib.Object.GetObject (client, false) as Client;
				client_managed.OnAllowCancel (allow_cancel);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideAllowCancel (GLib.GType gtype)
		{
			if (AllowCancelVMCallback == null)
				AllowCancelVMCallback = new AllowCancelVMDelegate (allowcancel_cb);
			OverrideVirtualMethod (gtype, "allow-cancel", AllowCancelVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(PackageKit.Client), ConnectionMethod="OverrideAllowCancel")]
		protected virtual void OnAllowCancel (bool allow_cancel)
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (2);
			GLib.Value[] vals = new GLib.Value [2];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (allow_cancel);
			inst_and_params.Append (vals [1]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("allow-cancel")]
		public event PackageKit.AllowCancelHandler AllowCancel {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "allow-cancel", typeof (PackageKit.AllowCancelArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "allow-cancel", typeof (PackageKit.AllowCancelArgs));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void TransactionVMDelegate (IntPtr client, IntPtr obj);

		static TransactionVMDelegate TransactionVMCallback;

		static void transaction_cb (IntPtr client, IntPtr obj)
		{
			try {
				Client client_managed = GLib.Object.GetObject (client, false) as Client;
				client_managed.OnTransaction (obj == IntPtr.Zero ? null : (PackageKit.TransactionObj) GLib.Opaque.GetOpaque (obj, typeof (PackageKit.TransactionObj), false));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideTransaction (GLib.GType gtype)
		{
			if (TransactionVMCallback == null)
				TransactionVMCallback = new TransactionVMDelegate (transaction_cb);
			OverrideVirtualMethod (gtype, "transaction", TransactionVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(PackageKit.Client), ConnectionMethod="OverrideTransaction")]
		protected virtual void OnTransaction (PackageKit.TransactionObj obj)
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (2);
			GLib.Value[] vals = new GLib.Value [2];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (obj);
			inst_and_params.Append (vals [1]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.CDeclCallback]
		delegate void TransactionSignalDelegate (IntPtr arg0, IntPtr arg1, IntPtr gch);

		static void TransactionSignalCallback (IntPtr arg0, IntPtr arg1, IntPtr gch)
		{
			PackageKit.TransactionArgs args = new PackageKit.TransactionArgs ();
			try {
				GLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;
				if (sig == null)
					throw new Exception("Unknown signal GC handle received " + gch);

				args.Args = new object[1];
				args.Args[0] = arg1 == IntPtr.Zero ? null : (PackageKit.TransactionObj) GLib.Opaque.GetOpaque (arg1, typeof (PackageKit.TransactionObj), false);
				PackageKit.TransactionHandler handler = (PackageKit.TransactionHandler) sig.Handler;
				handler (GLib.Object.GetObject (arg0), args);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.Signal("transaction")]
		public event PackageKit.TransactionHandler Transaction {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "transaction", new TransactionSignalDelegate(TransactionSignalCallback));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "transaction", new TransactionSignalDelegate(TransactionSignalCallback));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void RepoSignatureRequiredVMDelegate (IntPtr client, IntPtr package_id, IntPtr repository_name, IntPtr key_url, IntPtr key_userid, IntPtr key_id, IntPtr key_fingerprint, IntPtr key_timestamp, int type);

		static RepoSignatureRequiredVMDelegate RepoSignatureRequiredVMCallback;

		static void reposignaturerequired_cb (IntPtr client, IntPtr package_id, IntPtr repository_name, IntPtr key_url, IntPtr key_userid, IntPtr key_id, IntPtr key_fingerprint, IntPtr key_timestamp, int type)
		{
			try {
				Client client_managed = GLib.Object.GetObject (client, false) as Client;
				client_managed.OnRepoSignatureRequired (GLib.Marshaller.Utf8PtrToString (package_id), GLib.Marshaller.Utf8PtrToString (repository_name), GLib.Marshaller.Utf8PtrToString (key_url), GLib.Marshaller.Utf8PtrToString (key_userid), GLib.Marshaller.Utf8PtrToString (key_id), GLib.Marshaller.Utf8PtrToString (key_fingerprint), GLib.Marshaller.Utf8PtrToString (key_timestamp), (PackageKit.SigTypeEnum) type);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideRepoSignatureRequired (GLib.GType gtype)
		{
			if (RepoSignatureRequiredVMCallback == null)
				RepoSignatureRequiredVMCallback = new RepoSignatureRequiredVMDelegate (reposignaturerequired_cb);
			OverrideVirtualMethod (gtype, "repo-signature-required", RepoSignatureRequiredVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(PackageKit.Client), ConnectionMethod="OverrideRepoSignatureRequired")]
		protected virtual void OnRepoSignatureRequired (string package_id, string repository_name, string key_url, string key_userid, string key_id, string key_fingerprint, string key_timestamp, PackageKit.SigTypeEnum type)
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (9);
			GLib.Value[] vals = new GLib.Value [9];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (package_id);
			inst_and_params.Append (vals [1]);
			vals [2] = new GLib.Value (repository_name);
			inst_and_params.Append (vals [2]);
			vals [3] = new GLib.Value (key_url);
			inst_and_params.Append (vals [3]);
			vals [4] = new GLib.Value (key_userid);
			inst_and_params.Append (vals [4]);
			vals [5] = new GLib.Value (key_id);
			inst_and_params.Append (vals [5]);
			vals [6] = new GLib.Value (key_fingerprint);
			inst_and_params.Append (vals [6]);
			vals [7] = new GLib.Value (key_timestamp);
			inst_and_params.Append (vals [7]);
			vals [8] = new GLib.Value (type);
			inst_and_params.Append (vals [8]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("repo-signature-required")]
		public event PackageKit.RepoSignatureRequiredHandler RepoSignatureRequired {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "repo-signature-required", typeof (PackageKit.RepoSignatureRequiredArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "repo-signature-required", typeof (PackageKit.RepoSignatureRequiredArgs));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void CategoryVMDelegate (IntPtr client, IntPtr obj);

		static CategoryVMDelegate CategoryVMCallback;

		static void category_cb (IntPtr client, IntPtr obj)
		{
			try {
				Client client_managed = GLib.Object.GetObject (client, false) as Client;
				client_managed.OnCategory (obj == IntPtr.Zero ? null : (PackageKit.CategoryObj) GLib.Opaque.GetOpaque (obj, typeof (PackageKit.CategoryObj), false));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideCategory (GLib.GType gtype)
		{
			if (CategoryVMCallback == null)
				CategoryVMCallback = new CategoryVMDelegate (category_cb);
			OverrideVirtualMethod (gtype, "category", CategoryVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(PackageKit.Client), ConnectionMethod="OverrideCategory")]
		protected virtual void OnCategory (PackageKit.CategoryObj obj)
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (2);
			GLib.Value[] vals = new GLib.Value [2];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (obj);
			inst_and_params.Append (vals [1]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.CDeclCallback]
		delegate void CategorySignalDelegate (IntPtr arg0, IntPtr arg1, IntPtr gch);

		static void CategorySignalCallback (IntPtr arg0, IntPtr arg1, IntPtr gch)
		{
			PackageKit.CategoryArgs args = new PackageKit.CategoryArgs ();
			try {
				GLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;
				if (sig == null)
					throw new Exception("Unknown signal GC handle received " + gch);

				args.Args = new object[1];
				args.Args[0] = arg1 == IntPtr.Zero ? null : (PackageKit.CategoryObj) GLib.Opaque.GetOpaque (arg1, typeof (PackageKit.CategoryObj), false);
				PackageKit.CategoryHandler handler = (PackageKit.CategoryHandler) sig.Handler;
				handler (GLib.Object.GetObject (arg0), args);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.Signal("category")]
		public event PackageKit.CategoryHandler Category {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "category", new CategorySignalDelegate(CategorySignalCallback));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "category", new CategorySignalDelegate(CategorySignalCallback));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void EulaRequiredVMDelegate (IntPtr client, IntPtr eula_id, IntPtr package_id, IntPtr vendor_name, IntPtr license_agreement);

		static EulaRequiredVMDelegate EulaRequiredVMCallback;

		static void eularequired_cb (IntPtr client, IntPtr eula_id, IntPtr package_id, IntPtr vendor_name, IntPtr license_agreement)
		{
			try {
				Client client_managed = GLib.Object.GetObject (client, false) as Client;
				client_managed.OnEulaRequired (GLib.Marshaller.Utf8PtrToString (eula_id), GLib.Marshaller.Utf8PtrToString (package_id), GLib.Marshaller.Utf8PtrToString (vendor_name), GLib.Marshaller.Utf8PtrToString (license_agreement));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideEulaRequired (GLib.GType gtype)
		{
			if (EulaRequiredVMCallback == null)
				EulaRequiredVMCallback = new EulaRequiredVMDelegate (eularequired_cb);
			OverrideVirtualMethod (gtype, "eula-required", EulaRequiredVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(PackageKit.Client), ConnectionMethod="OverrideEulaRequired")]
		protected virtual void OnEulaRequired (string eula_id, string package_id, string vendor_name, string license_agreement)
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (5);
			GLib.Value[] vals = new GLib.Value [5];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (eula_id);
			inst_and_params.Append (vals [1]);
			vals [2] = new GLib.Value (package_id);
			inst_and_params.Append (vals [2]);
			vals [3] = new GLib.Value (vendor_name);
			inst_and_params.Append (vals [3]);
			vals [4] = new GLib.Value (license_agreement);
			inst_and_params.Append (vals [4]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("eula-required")]
		public event PackageKit.EulaRequiredHandler EulaRequired {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "eula-required", typeof (PackageKit.EulaRequiredArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "eula-required", typeof (PackageKit.EulaRequiredArgs));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void FinishedVMDelegate (IntPtr client, int exit, uint runtime);

		static FinishedVMDelegate FinishedVMCallback;

		static void finished_cb (IntPtr client, int exit, uint runtime)
		{
			try {
				Client client_managed = GLib.Object.GetObject (client, false) as Client;
				client_managed.OnFinished ((PackageKit.ExitEnum) exit, runtime);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideFinished (GLib.GType gtype)
		{
			if (FinishedVMCallback == null)
				FinishedVMCallback = new FinishedVMDelegate (finished_cb);
			OverrideVirtualMethod (gtype, "finished", FinishedVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(PackageKit.Client), ConnectionMethod="OverrideFinished")]
		protected virtual void OnFinished (PackageKit.ExitEnum exit, uint runtime)
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (3);
			GLib.Value[] vals = new GLib.Value [3];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (exit);
			inst_and_params.Append (vals [1]);
			vals [2] = new GLib.Value (runtime);
			inst_and_params.Append (vals [2]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.CDeclCallback]
		delegate void FinishedSignalDelegate (IntPtr arg0, int arg1, uint arg2, IntPtr gch);

		static void FinishedSignalCallback (IntPtr arg0, int arg1, uint arg2, IntPtr gch)
		{
			PackageKit.FinishedArgs args = new PackageKit.FinishedArgs ();
			try {
				GLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;
				if (sig == null)
					throw new Exception("Unknown signal GC handle received " + gch);

				args.Args = new object[2];
				args.Args[0] = (PackageKit.ExitEnum) arg1;
				args.Args[1] = arg2;
				PackageKit.FinishedHandler handler = (PackageKit.FinishedHandler) sig.Handler;
				handler (GLib.Object.GetObject (arg0), args);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.Signal("finished")]
		public event PackageKit.FinishedHandler Finished {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "finished", new FinishedSignalDelegate(FinishedSignalCallback));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "finished", new FinishedSignalDelegate(FinishedSignalCallback));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void DestroyVMDelegate (IntPtr client, int exit, uint runtime);

		static DestroyVMDelegate DestroyVMCallback;

		static void destroy_cb (IntPtr client, int exit, uint runtime)
		{
			try {
				Client client_managed = GLib.Object.GetObject (client, false) as Client;
				client_managed.OnDestroy ((PackageKit.ExitEnum) exit, runtime);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideDestroy (GLib.GType gtype)
		{
			if (DestroyVMCallback == null)
				DestroyVMCallback = new DestroyVMDelegate (destroy_cb);
			OverrideVirtualMethod (gtype, "destroy", DestroyVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(PackageKit.Client), ConnectionMethod="OverrideDestroy")]
		protected virtual void OnDestroy (PackageKit.ExitEnum exit, uint runtime)
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (3);
			GLib.Value[] vals = new GLib.Value [3];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (exit);
			inst_and_params.Append (vals [1]);
			vals [2] = new GLib.Value (runtime);
			inst_and_params.Append (vals [2]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("destroy")]
		public event PackageKit.DestroyHandler Destroy {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "destroy", typeof (PackageKit.DestroyArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "destroy", typeof (PackageKit.DestroyArgs));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void FilesVMDelegate (IntPtr client, IntPtr package_id, IntPtr filelist);

		static FilesVMDelegate FilesVMCallback;

		static void files_cb (IntPtr client, IntPtr package_id, IntPtr filelist)
		{
			try {
				Client client_managed = GLib.Object.GetObject (client, false) as Client;
				client_managed.OnFiles (GLib.Marshaller.Utf8PtrToString (package_id), GLib.Marshaller.Utf8PtrToString (filelist));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideFiles (GLib.GType gtype)
		{
			if (FilesVMCallback == null)
				FilesVMCallback = new FilesVMDelegate (files_cb);
			OverrideVirtualMethod (gtype, "files", FilesVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(PackageKit.Client), ConnectionMethod="OverrideFiles")]
		protected virtual void OnFiles (string package_id, string filelist)
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (3);
			GLib.Value[] vals = new GLib.Value [3];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (package_id);
			inst_and_params.Append (vals [1]);
			vals [2] = new GLib.Value (filelist);
			inst_and_params.Append (vals [2]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("files")]
		public event PackageKit.FilesHandler Files {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "files", typeof (PackageKit.FilesArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "files", typeof (PackageKit.FilesArgs));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void DistroUpgradeVMDelegate (IntPtr client, int type, IntPtr name, IntPtr summary);

		static DistroUpgradeVMDelegate DistroUpgradeVMCallback;

		static void distroupgrade_cb (IntPtr client, int type, IntPtr name, IntPtr summary)
		{
			try {
				Client client_managed = GLib.Object.GetObject (client, false) as Client;
				client_managed.OnDistroUpgrade ((PackageKit.UpdateStateEnum) type, GLib.Marshaller.Utf8PtrToString (name), GLib.Marshaller.Utf8PtrToString (summary));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideDistroUpgrade (GLib.GType gtype)
		{
			if (DistroUpgradeVMCallback == null)
				DistroUpgradeVMCallback = new DistroUpgradeVMDelegate (distroupgrade_cb);
			OverrideVirtualMethod (gtype, "distro-upgrade", DistroUpgradeVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(PackageKit.Client), ConnectionMethod="OverrideDistroUpgrade")]
		protected virtual void OnDistroUpgrade (PackageKit.UpdateStateEnum type, string name, string summary)
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (4);
			GLib.Value[] vals = new GLib.Value [4];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (type);
			inst_and_params.Append (vals [1]);
			vals [2] = new GLib.Value (name);
			inst_and_params.Append (vals [2]);
			vals [3] = new GLib.Value (summary);
			inst_and_params.Append (vals [3]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.CDeclCallback]
		delegate void DistroUpgradeSignalDelegate (IntPtr arg0, int arg1, IntPtr arg2, IntPtr arg3, IntPtr gch);

		static void DistroUpgradeSignalCallback (IntPtr arg0, int arg1, IntPtr arg2, IntPtr arg3, IntPtr gch)
		{
			PackageKit.DistroUpgradeArgs args = new PackageKit.DistroUpgradeArgs ();
			try {
				GLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;
				if (sig == null)
					throw new Exception("Unknown signal GC handle received " + gch);

				args.Args = new object[3];
				args.Args[0] = (PackageKit.UpdateStateEnum) arg1;
				args.Args[1] = GLib.Marshaller.Utf8PtrToString (arg2);
				args.Args[2] = GLib.Marshaller.Utf8PtrToString (arg3);
				PackageKit.DistroUpgradeHandler handler = (PackageKit.DistroUpgradeHandler) sig.Handler;
				handler (GLib.Object.GetObject (arg0), args);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.Signal("distro-upgrade")]
		public event PackageKit.DistroUpgradeHandler DistroUpgrade {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "distro-upgrade", new DistroUpgradeSignalDelegate(DistroUpgradeSignalCallback));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "distro-upgrade", new DistroUpgradeSignalDelegate(DistroUpgradeSignalCallback));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void RepoDetailVMDelegate (IntPtr client, IntPtr repo_id, IntPtr description, bool enabled);

		static RepoDetailVMDelegate RepoDetailVMCallback;

		static void repodetail_cb (IntPtr client, IntPtr repo_id, IntPtr description, bool enabled)
		{
			try {
				Client client_managed = GLib.Object.GetObject (client, false) as Client;
				client_managed.OnRepoDetail (GLib.Marshaller.Utf8PtrToString (repo_id), GLib.Marshaller.Utf8PtrToString (description), enabled);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideRepoDetail (GLib.GType gtype)
		{
			if (RepoDetailVMCallback == null)
				RepoDetailVMCallback = new RepoDetailVMDelegate (repodetail_cb);
			OverrideVirtualMethod (gtype, "repo-detail", RepoDetailVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(PackageKit.Client), ConnectionMethod="OverrideRepoDetail")]
		protected virtual void OnRepoDetail (string repo_id, string description, bool enabled)
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (4);
			GLib.Value[] vals = new GLib.Value [4];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (repo_id);
			inst_and_params.Append (vals [1]);
			vals [2] = new GLib.Value (description);
			inst_and_params.Append (vals [2]);
			vals [3] = new GLib.Value (enabled);
			inst_and_params.Append (vals [3]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("repo-detail")]
		public event PackageKit.RepoDetailHandler RepoDetail {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "repo-detail", typeof (PackageKit.RepoDetailArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "repo-detail", typeof (PackageKit.RepoDetailArgs));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void RequireRestartVMDelegate (IntPtr client, int restart, IntPtr id);

		static RequireRestartVMDelegate RequireRestartVMCallback;

		static void requirerestart_cb (IntPtr client, int restart, IntPtr id)
		{
			try {
				Client client_managed = GLib.Object.GetObject (client, false) as Client;
				client_managed.OnRequireRestart ((PackageKit.RestartEnum) restart, id == IntPtr.Zero ? null : (PackageKit.PackageId) GLib.Opaque.GetOpaque (id, typeof (PackageKit.PackageId), false));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideRequireRestart (GLib.GType gtype)
		{
			if (RequireRestartVMCallback == null)
				RequireRestartVMCallback = new RequireRestartVMDelegate (requirerestart_cb);
			OverrideVirtualMethod (gtype, "require-restart", RequireRestartVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(PackageKit.Client), ConnectionMethod="OverrideRequireRestart")]
		protected virtual void OnRequireRestart (PackageKit.RestartEnum restart, PackageKit.PackageId id)
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (3);
			GLib.Value[] vals = new GLib.Value [3];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (restart);
			inst_and_params.Append (vals [1]);
			vals [2] = new GLib.Value (id);
			inst_and_params.Append (vals [2]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.CDeclCallback]
		delegate void RequireRestartSignalDelegate (IntPtr arg0, int arg1, IntPtr arg2, IntPtr gch);

		static void RequireRestartSignalCallback (IntPtr arg0, int arg1, IntPtr arg2, IntPtr gch)
		{
			PackageKit.RequireRestartArgs args = new PackageKit.RequireRestartArgs ();
			try {
				GLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;
				if (sig == null)
					throw new Exception("Unknown signal GC handle received " + gch);

				args.Args = new object[2];
				args.Args[0] = (PackageKit.RestartEnum) arg1;
				args.Args[1] = arg2 == IntPtr.Zero ? null : (PackageKit.PackageId) GLib.Opaque.GetOpaque (arg2, typeof (PackageKit.PackageId), false);
				PackageKit.RequireRestartHandler handler = (PackageKit.RequireRestartHandler) sig.Handler;
				handler (GLib.Object.GetObject (arg0), args);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.Signal("require-restart")]
		public event PackageKit.RequireRestartHandler RequireRestart {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "require-restart", new RequireRestartSignalDelegate(RequireRestartSignalCallback));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "require-restart", new RequireRestartSignalDelegate(RequireRestartSignalCallback));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void UpdateDetailVMDelegate (IntPtr client, IntPtr update_detail);

		static UpdateDetailVMDelegate UpdateDetailVMCallback;

		static void updatedetail_cb (IntPtr client, IntPtr update_detail)
		{
			try {
				Client client_managed = GLib.Object.GetObject (client, false) as Client;
				client_managed.OnUpdateDetail (update_detail == IntPtr.Zero ? null : (PackageKit.UpdateDetailObj) GLib.Opaque.GetOpaque (update_detail, typeof (PackageKit.UpdateDetailObj), false));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideUpdateDetail (GLib.GType gtype)
		{
			if (UpdateDetailVMCallback == null)
				UpdateDetailVMCallback = new UpdateDetailVMDelegate (updatedetail_cb);
			OverrideVirtualMethod (gtype, "update-detail", UpdateDetailVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(PackageKit.Client), ConnectionMethod="OverrideUpdateDetail")]
		protected virtual void OnUpdateDetail (PackageKit.UpdateDetailObj update_detail)
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (2);
			GLib.Value[] vals = new GLib.Value [2];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (update_detail);
			inst_and_params.Append (vals [1]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.CDeclCallback]
		delegate void UpdateDetailSignalDelegate (IntPtr arg0, IntPtr arg1, IntPtr gch);

		static void UpdateDetailSignalCallback (IntPtr arg0, IntPtr arg1, IntPtr gch)
		{
			PackageKit.UpdateDetailArgs args = new PackageKit.UpdateDetailArgs ();
			try {
				GLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;
				if (sig == null)
					throw new Exception("Unknown signal GC handle received " + gch);

				args.Args = new object[1];
				args.Args[0] = arg1 == IntPtr.Zero ? null : (PackageKit.UpdateDetailObj) GLib.Opaque.GetOpaque (arg1, typeof (PackageKit.UpdateDetailObj), false);
				PackageKit.UpdateDetailHandler handler = (PackageKit.UpdateDetailHandler) sig.Handler;
				handler (GLib.Object.GetObject (arg0), args);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.Signal("update-detail")]
		public event PackageKit.UpdateDetailHandler UpdateDetail {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "update-detail", new UpdateDetailSignalDelegate(UpdateDetailSignalCallback));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "update-detail", new UpdateDetailSignalDelegate(UpdateDetailSignalCallback));
				sig.RemoveDelegate (value);
			}
		}

		[GLib.CDeclCallback]
		delegate void StatusChangedVMDelegate (IntPtr client, int status);

		static StatusChangedVMDelegate StatusChangedVMCallback;

		static void statuschanged_cb (IntPtr client, int status)
		{
			try {
				Client client_managed = GLib.Object.GetObject (client, false) as Client;
				client_managed.OnStatusChanged ((PackageKit.StatusEnum) status);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideStatusChanged (GLib.GType gtype)
		{
			if (StatusChangedVMCallback == null)
				StatusChangedVMCallback = new StatusChangedVMDelegate (statuschanged_cb);
			OverrideVirtualMethod (gtype, "status-changed", StatusChangedVMCallback);
		}

		[GLib.DefaultSignalHandler(Type=typeof(PackageKit.Client), ConnectionMethod="OverrideStatusChanged")]
		protected virtual void OnStatusChanged (PackageKit.StatusEnum status)
		{
			GLib.Value ret = GLib.Value.Empty;
			GLib.ValueArray inst_and_params = new GLib.ValueArray (2);
			GLib.Value[] vals = new GLib.Value [2];
			vals [0] = new GLib.Value (this);
			inst_and_params.Append (vals [0]);
			vals [1] = new GLib.Value (status);
			inst_and_params.Append (vals [1]);
			g_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);
			foreach (GLib.Value v in vals)
				v.Dispose ();
		}

		[GLib.Signal("status-changed")]
		public event PackageKit.StatusChangedHandler StatusChanged {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "status-changed", typeof (PackageKit.StatusChangedArgs));
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "status-changed", typeof (PackageKit.StatusChangedArgs));
				sig.RemoveDelegate (value);
			}
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_get_depends(IntPtr raw, ulong filters, IntPtr package_ids, bool recursive, out IntPtr error);

		public unsafe bool GetDepends(ulong filters, string package_ids, bool recursive) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_get_depends(Handle, filters, GLib.Marshaller.StringToPtrGStrdup(package_ids), recursive, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_get_packages(IntPtr raw, ulong filters, out IntPtr error);

		public unsafe bool GetPackages(ulong filters) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_get_packages(Handle, filters, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_get_requires(IntPtr raw, ulong filters, IntPtr[] package_ids, bool recursive, out IntPtr error);

		public unsafe bool GetRequires(ulong filters, string[] package_ids, bool recursive) {
			int cnt_package_ids = package_ids == null ? 0 : package_ids.Length;
			IntPtr[] native_package_ids = new IntPtr [cnt_package_ids + 1];
			for (int i = 0; i < cnt_package_ids; i++)
				native_package_ids [i] = GLib.Marshaller.StringToPtrGStrdup(package_ids[i]);
			native_package_ids [cnt_package_ids] = IntPtr.Zero;
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_get_requires(Handle, filters, native_package_ids, recursive, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern IntPtr pk_client_get_type();

		public static new GLib.GType GType { 
			get {
				IntPtr raw_ret = pk_client_get_type();
				GLib.GType ret = new GLib.GType(raw_ret);
				return ret;
			}
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_remove_packages(IntPtr raw, IntPtr package_ids, bool allow_deps, bool autoremove, out IntPtr error);

		public unsafe bool RemovePackages(string package_ids, bool allow_deps, bool autoremove) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_remove_packages(Handle, GLib.Marshaller.StringToPtrGStrdup(package_ids), allow_deps, autoremove, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_get_update_detail(IntPtr raw, IntPtr[] package_ids, out IntPtr error);

		public unsafe bool GetUpdateDetail(string[] package_ids) {
			int cnt_package_ids = package_ids == null ? 0 : package_ids.Length;
			IntPtr[] native_package_ids = new IntPtr [cnt_package_ids + 1];
			for (int i = 0; i < cnt_package_ids; i++)
				native_package_ids [i] = GLib.Marshaller.StringToPtrGStrdup(package_ids[i]);
			native_package_ids [cnt_package_ids] = IntPtr.Zero;
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_get_update_detail(Handle, native_package_ids, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_what_provides(IntPtr raw, ulong filters, int provides, IntPtr search, out IntPtr error);

		public unsafe bool WhatProvides(ulong filters, PackageKit.ProvidesEnum provides, string search) {
			IntPtr native_search = GLib.Marshaller.StringToPtrGStrdup (search);
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_what_provides(Handle, filters, (int) provides, native_search, out error);
			bool ret = raw_ret;
			GLib.Marshaller.Free (native_search);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_reset(IntPtr raw, out IntPtr error);

		public unsafe bool Reset() {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_reset(Handle, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_get_role(IntPtr raw, out int role, IntPtr text, out IntPtr error);

		public unsafe bool GetRole(out PackageKit.RoleEnum role, string text) {
			int native_role;
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_get_role(Handle, out native_role, GLib.Marshaller.StringToPtrGStrdup(text), out error);
			bool ret = raw_ret;
			role = (PackageKit.RoleEnum) native_role;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_install_files(IntPtr raw, bool only_trusted, IntPtr[] files_rel, out IntPtr error);

		public unsafe bool InstallFiles(bool only_trusted, string[] files_rel) {
			int cnt_files_rel = files_rel == null ? 0 : files_rel.Length;
			IntPtr[] native_files_rel = new IntPtr [cnt_files_rel + 1];
			for (int i = 0; i < cnt_files_rel; i++)
				native_files_rel [i] = GLib.Marshaller.StringToPtrGStrdup(files_rel[i]);
			native_files_rel [cnt_files_rel] = IntPtr.Zero;
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_install_files(Handle, only_trusted, native_files_rel, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_download_packages(IntPtr raw, IntPtr[] package_ids, IntPtr directory, out IntPtr error);

		public unsafe bool DownloadPackages(string[] package_ids, string directory) {
			int cnt_package_ids = package_ids == null ? 0 : package_ids.Length;
			IntPtr[] native_package_ids = new IntPtr [cnt_package_ids + 1];
			for (int i = 0; i < cnt_package_ids; i++)
				native_package_ids [i] = GLib.Marshaller.StringToPtrGStrdup(package_ids[i]);
			native_package_ids [cnt_package_ids] = IntPtr.Zero;
			IntPtr native_directory = GLib.Marshaller.StringToPtrGStrdup (directory);
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_download_packages(Handle, native_package_ids, native_directory, out error);
			bool ret = raw_ret;
			GLib.Marshaller.Free (native_directory);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_search_file(IntPtr raw, ulong filters, IntPtr search, out IntPtr error);

		public unsafe bool SearchFile(ulong filters, string search) {
			IntPtr native_search = GLib.Marshaller.StringToPtrGStrdup (search);
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_search_file(Handle, filters, native_search, out error);
			bool ret = raw_ret;
			GLib.Marshaller.Free (native_search);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_set_timeout(IntPtr raw, int timeout, out IntPtr error);

		public unsafe bool SetTimeout(int timeout) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_set_timeout(Handle, timeout, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern IntPtr pk_client_get_cached_objects(IntPtr raw);

		public PackageKit.ObjList CachedObjects { 
			get {
				IntPtr raw_ret = pk_client_get_cached_objects(Handle);
				PackageKit.ObjList ret = GLib.Object.GetObject(raw_ret) as PackageKit.ObjList;
				return ret;
			}
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_repo_set_data(IntPtr raw, IntPtr repo_id, IntPtr parameter, IntPtr value, out IntPtr error);

		public unsafe bool RepoSetData(string repo_id, string parameter, string value) {
			IntPtr native_repo_id = GLib.Marshaller.StringToPtrGStrdup (repo_id);
			IntPtr native_parameter = GLib.Marshaller.StringToPtrGStrdup (parameter);
			IntPtr native_value = GLib.Marshaller.StringToPtrGStrdup (value);
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_repo_set_data(Handle, native_repo_id, native_parameter, native_value, out error);
			bool ret = raw_ret;
			GLib.Marshaller.Free (native_repo_id);
			GLib.Marshaller.Free (native_parameter);
			GLib.Marshaller.Free (native_value);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_get_allow_cancel(IntPtr raw, out bool allow_cancel, out IntPtr error);

		public unsafe bool GetAllowCancel(out bool allow_cancel) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_get_allow_cancel(Handle, out allow_cancel, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_get_files(IntPtr raw, IntPtr package_ids, out IntPtr error);

		public unsafe bool GetFiles(string package_ids) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_get_files(Handle, GLib.Marshaller.StringToPtrGStrdup(package_ids), out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_get_package(IntPtr raw, IntPtr package, out IntPtr error);

		public unsafe bool GetPackage(string package) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_get_package(Handle, GLib.Marshaller.StringToPtrGStrdup(package), out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_is_caller_active(IntPtr raw, out bool is_active, out IntPtr error);

		public unsafe bool IsCallerActive(out bool is_active) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_is_caller_active(Handle, out is_active, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_resolve(IntPtr raw, ulong filters, IntPtr packages, out IntPtr error);

		public unsafe bool Resolve(ulong filters, string packages) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_resolve(Handle, filters, GLib.Marshaller.StringToPtrGStrdup(packages), out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_install_signature(IntPtr raw, int type, IntPtr key_id, IntPtr package_id, out IntPtr error);

		public unsafe bool InstallSignature(PackageKit.SigTypeEnum type, string key_id, string package_id) {
			IntPtr native_key_id = GLib.Marshaller.StringToPtrGStrdup (key_id);
			IntPtr native_package_id = GLib.Marshaller.StringToPtrGStrdup (package_id);
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_install_signature(Handle, (int) type, native_key_id, native_package_id, out error);
			bool ret = raw_ret;
			GLib.Marshaller.Free (native_key_id);
			GLib.Marshaller.Free (native_package_id);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_install_packages(IntPtr raw, IntPtr[] package_ids, out IntPtr error);

		public unsafe bool InstallPackages(string[] package_ids) {
			int cnt_package_ids = package_ids == null ? 0 : package_ids.Length;
			IntPtr[] native_package_ids = new IntPtr [cnt_package_ids + 1];
			for (int i = 0; i < cnt_package_ids; i++)
				native_package_ids [i] = GLib.Marshaller.StringToPtrGStrdup(package_ids[i]);
			native_package_ids [cnt_package_ids] = IntPtr.Zero;
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_install_packages(Handle, native_package_ids, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_search_name(IntPtr raw, ulong filters, IntPtr search, out IntPtr error);

		public unsafe bool SearchName(ulong filters, string search) {
			IntPtr native_search = GLib.Marshaller.StringToPtrGStrdup (search);
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_search_name(Handle, filters, native_search, out error);
			bool ret = raw_ret;
			GLib.Marshaller.Free (native_search);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern int pk_client_get_require_restart(IntPtr raw);

		public PackageKit.RestartEnum RequireRestartStatus { 
			get {
				int raw_ret = pk_client_get_require_restart(Handle);
				PackageKit.RestartEnum ret = (PackageKit.RestartEnum) raw_ret;
				return ret;
			}
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_set_synchronous(IntPtr raw, bool synchronous, out IntPtr error);

		public unsafe bool SetSynchronous(bool synchronous) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_set_synchronous(Handle, synchronous, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_update_packages(IntPtr raw, IntPtr[] package_ids, out IntPtr error);

		public unsafe bool UpdatePackages(string[] package_ids) {
			int cnt_package_ids = package_ids == null ? 0 : package_ids.Length;
			IntPtr[] native_package_ids = new IntPtr [cnt_package_ids + 1];
			for (int i = 0; i < cnt_package_ids; i++)
				native_package_ids [i] = GLib.Marshaller.StringToPtrGStrdup(package_ids[i]);
			native_package_ids [cnt_package_ids] = IntPtr.Zero;
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_update_packages(Handle, native_package_ids, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern IntPtr pk_client_get_package_list(IntPtr raw);

		public PackageKit.PackageList PackageList { 
			get {
				IntPtr raw_ret = pk_client_get_package_list(Handle);
				PackageKit.PackageList ret = GLib.Object.GetObject(raw_ret) as PackageKit.PackageList;
				return ret;
			}
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_accept_eula(IntPtr raw, IntPtr eula_id, out IntPtr error);

		public unsafe bool AcceptEula(string eula_id) {
			IntPtr native_eula_id = GLib.Marshaller.StringToPtrGStrdup (eula_id);
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_accept_eula(Handle, native_eula_id, out error);
			bool ret = raw_ret;
			GLib.Marshaller.Free (native_eula_id);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_get_progress(IntPtr raw, out uint percentage, out uint subpercentage, out uint elapsed, out uint remaining, out IntPtr error);

		public unsafe bool GetProgress(out uint percentage, out uint subpercentage, out uint elapsed, out uint remaining) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_get_progress(Handle, out percentage, out subpercentage, out elapsed, out remaining, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_set_locale(IntPtr raw, IntPtr code, out IntPtr error);

		public unsafe bool SetLocale(string code) {
			IntPtr native_code = GLib.Marshaller.StringToPtrGStrdup (code);
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_set_locale(Handle, native_code, out error);
			bool ret = raw_ret;
			GLib.Marshaller.Free (native_code);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_get_details(IntPtr raw, IntPtr[] package_ids, out IntPtr error);

		public unsafe bool GetDetails(string[] package_ids) {
			int cnt_package_ids = package_ids == null ? 0 : package_ids.Length;
			IntPtr[] native_package_ids = new IntPtr [cnt_package_ids + 1];
			for (int i = 0; i < cnt_package_ids; i++)
				native_package_ids [i] = GLib.Marshaller.StringToPtrGStrdup(package_ids[i]);
			native_package_ids [cnt_package_ids] = IntPtr.Zero;
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_get_details(Handle, native_package_ids, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_get_updates(IntPtr raw, ulong filters, out IntPtr error);

		public unsafe bool GetUpdates(ulong filters) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_get_updates(Handle, filters, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_install_file(IntPtr raw, bool only_trusted, IntPtr file_rel, out IntPtr error);

		public unsafe bool InstallFile(bool only_trusted, string file_rel) {
			IntPtr native_file_rel = GLib.Marshaller.StringToPtrGStrdup (file_rel);
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_install_file(Handle, only_trusted, native_file_rel, out error);
			bool ret = raw_ret;
			GLib.Marshaller.Free (native_file_rel);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_refresh_cache(IntPtr raw, bool force, out IntPtr error);

		public unsafe bool RefreshCache(bool force) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_refresh_cache(Handle, force, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_search_group(IntPtr raw, ulong filters, IntPtr search, out IntPtr error);

		public unsafe bool SearchGroup(ulong filters, string search) {
			IntPtr native_search = GLib.Marshaller.StringToPtrGStrdup (search);
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_search_group(Handle, filters, native_search, out error);
			bool ret = raw_ret;
			GLib.Marshaller.Free (native_search);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_search_details(IntPtr raw, ulong filters, IntPtr search, out IntPtr error);

		public unsafe bool SearchDetails(ulong filters, string search) {
			IntPtr native_search = GLib.Marshaller.StringToPtrGStrdup (search);
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_search_details(Handle, filters, native_search, out error);
			bool ret = raw_ret;
			GLib.Marshaller.Free (native_search);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_update_system(IntPtr raw, out IntPtr error);

		public unsafe bool UpdateSystem() {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_update_system(Handle, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_get_categories(IntPtr raw, out IntPtr error);

		public unsafe bool GetCategories() {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_get_categories(Handle, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_get_status(IntPtr raw, out int status, out IntPtr error);

		public unsafe bool GetStatus(out PackageKit.StatusEnum status) {
			int native_status;
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_get_status(Handle, out native_status, out error);
			bool ret = raw_ret;
			status = (PackageKit.StatusEnum) native_status;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_repo_enable(IntPtr raw, IntPtr repo_id, bool enabled, out IntPtr error);

		public unsafe bool RepoEnable(string repo_id, bool enabled) {
			IntPtr native_repo_id = GLib.Marshaller.StringToPtrGStrdup (repo_id);
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_repo_enable(Handle, native_repo_id, enabled, out error);
			bool ret = raw_ret;
			GLib.Marshaller.Free (native_repo_id);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_cancel(IntPtr raw, out IntPtr error);

		public unsafe bool Cancel() {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_cancel(Handle, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_get_repo_list(IntPtr raw, ulong filters, out IntPtr error);

		public unsafe bool GetRepoList(ulong filters) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_get_repo_list(Handle, filters, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_requeue(IntPtr raw, out IntPtr error);

		public unsafe bool Requeue() {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_requeue(Handle, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern int pk_client_error_quark();

		public static int ErrorQuark() {
			int raw_ret = pk_client_error_quark();
			int ret = raw_ret;
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_get_distro_upgrades(IntPtr raw, out IntPtr error);

		public unsafe bool GetDistroUpgrades() {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_get_distro_upgrades(Handle, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern IntPtr pk_client_get_require_restart_list(IntPtr raw);

		public GLib.PtrArray RequireRestartList { 
			get {
				IntPtr raw_ret = pk_client_get_require_restart_list(Handle);
				GLib.PtrArray ret = new GLib.PtrArray(raw_ret);
				return ret;
			}
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_get_old_transactions(IntPtr raw, uint number, out IntPtr error);

		public unsafe bool GetOldTransactions(uint number) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_get_old_transactions(Handle, number, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_rollback(IntPtr raw, IntPtr transaction_id, out IntPtr error);

		public unsafe bool Rollback(string transaction_id) {
			IntPtr native_transaction_id = GLib.Marshaller.StringToPtrGStrdup (transaction_id);
			IntPtr error = IntPtr.Zero;
			bool raw_ret = pk_client_rollback(Handle, native_transaction_id, out error);
			bool ret = raw_ret;
			GLib.Marshaller.Free (native_transaction_id);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}


		static Client ()
		{
			GtkSharp.PackagekitSharp.ObjectManager.Initialize ();
		}
#endregion
#region Customized extensions
#line 1 "Client.custom"
/*
 * Client.custom: customization code for Client.cs
 *
 * Author(s):
 *	Stephane Delcroix  (stephane@delcroix.org)
 *
 * Copyright (c) 2009 Novell, Inc.
 *
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_set_tid(IntPtr raw, IntPtr tid, out IntPtr error);

		[DllImport("libpackagekit-glib.dll")]
		static extern IntPtr pk_client_get_tid(IntPtr raw);

		public string Tid {
			get {
				IntPtr raw_ret = pk_client_get_tid(Handle);
				string ret = GLib.Marshaller.PtrToStringGFree(raw_ret);
				return ret;
			}
			set {
				IntPtr native_tid = GLib.Marshaller.StringToPtrGStrdup (value);
				IntPtr error = IntPtr.Zero;
				pk_client_set_tid(Handle, native_tid, out error);
				GLib.Marshaller.Free (native_tid);
				if (error != IntPtr.Zero) throw new GLib.GException (error);
			}
		}

		[DllImport("libpackagekit-glib.dll")]
		static extern unsafe bool pk_client_set_use_buffer(IntPtr raw, bool use_buffer, out IntPtr error);

		[DllImport("libpackagekit-glib.dll")]
		static extern bool pk_client_get_use_buffer(IntPtr raw);

		public bool UseBuffer {
			get {
				bool raw_ret = pk_client_get_use_buffer(Handle);
				bool ret = raw_ret;
				return ret;
			}
			set {
				IntPtr error = IntPtr.Zero;
				pk_client_set_use_buffer(Handle, value, out error);
				if (error != IntPtr.Zero) throw new GLib.GException (error);
			}
		}





#endregion
	}
}
